# GoF의 Proxy 패턴(원격 프록시)

## 사용하게 된 이유
- 1인용 App을 사용할 경우 로컬에서 사용하기 때문에
  - 순차적 처리, 적은 성능을 요구하여 1대의 컴퓨터만으로 충분하였다.
- 점점 다인용(기업용)App으로 사용하게 되었을때 동시에 처리할 필요 가 많아지고 많은성능을 요구하여
  - App의 기능을 여러컴퓨터에 분할해서 실행하는 필요성이 대두되어 나온게
- " 분산 컴퓨터팅"(Distributed computing) 기술이다.
- 그래서 다른 컴퓨터(다른 프로세스)에서 메서드를 호출하는 기술이 필요해졌다.

## 원격 메서드를 호출하는 기술 
- Local 프로세스에서 Reomte프로세스에 접근이 불가하다
- 다른프로세스의 메모리를 직접 접근 할수 없다.
- 그렇기 때문에 특별한 기술이 필요하였다.


## 정의
- 다른 객체에 대한 접근을 제어하기 위한 보조역할을 하는 객체이다.
- 코드를 캡슐화하여 간단하게 한다. 진짜 객체를 원격개체를 통해 대리한다.  

## 프록시 패턴
- 다른 객체가 원본 객체에 대한 접근을 막고 대신 작업을 처리하는 행동 패턴이다.
- 이유는 원본 객체에 민감한 정보를 가지고 있거나 인스턴스화 하기 무겁거나 원본객체를 수정하기 어려울 때 사용한다.
- 원격 객체, 생성하기 힘든 객체, 보안이 중요한 객체와 같은 다른 객체로의 접근을 제어하는 대리인 객체를 만들수 있다.
- RMI의 Stub,skeleton 구조를 생각하면 이해하기 쉽다.

## 원격 프록시 패턴
- 프록시 클래스는 로컬에 있고 대상 객체는 원격 서버에 존재하는 경우 사용한다.
- 네트워크를 통해 요청을 받고 응답한다.
- 원격 프록시 패턴을 사용하기 위해 RMI를 활용한다.
- 프록시와 진짜 객체는 같은 인터페이스를 통해 구현되기 때문에 프록시가 대리인 역할을 할수 있는것이다.
- 그래서 진짜 객체의 작업을 처리하는 레퍼런스가 들어있기 때문에 접근을 제어할수 있다.


## RMI
- 클라이언트 객체가 호출을 하면 클라이언트 보조객체가 호출정보를 
- 서버 보조객체에게 전달 한다.
- 서버 보조객체는 받은 정보를 해석하고  서버 객체를 호출한다.
- 실행이 끝나면 역순으로 리턴한다.
```
A = 클라이언트
B = 서버

A객체 -> A보조객체 -> B보조 객체 -> B 객체

리턴
A객체 <- A보조객체 <- B보조 객체 <- B 객체

이때 
A보조 객체를 스텁(Stub)이라 부르고
B보조 객체를 스켈레톤(skeleton)이라고 부른다.
```