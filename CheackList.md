# 쳌

### 배열을 만들고 사용할 수 있는가? []
  - 배열은 같은 종류의 메모리를 쉽게 만드는 방법이다.
  - 1. 메모리명[] 메모리이름 = new 메모리이름[]
  - 2. 데이터 타입[] 변수명 = new 데이터 타입[]
  - 메모리이름, 변수명 = 레퍼런스
  - new 000[] = 인스턴스 

### 레퍼런스와 인스턴스의 의미를 설명할 수 있는가? []
  - 레퍼런스 메모리의 주소값을 저장한다.
  - 인스턴스 메모리의 값을 저장한다.

### 조건연산자의 사용법을 설명할 수 있는가? []
  - 문법: 조건? 표현식1 : 표현식2

### statement와 expression을 설명할 수 있는가? []
  - statement는 작업을 수행하는 명령
  - expression는 작업을 수행한 후 명령을 리턴하는 문장

### 전위 연산자와 후위 연산자의 사용법을 설명할 수 있는가? []
  - 전위연산자 (++,--)i 기존 변수값을 받고 연산한다.
  - 후위연산자 i(++,--)

### if문의 사용법을 설명할 수 있는가? [] lang.ex06
  1. 문법: if(조건) 문장, if(조건) {문장1,문장2}
  2. if문에서 여러개의 문장을 사용하고 싶다면 {}안에 문장을 넣는다.
  3. if문에는 문장 하나만 종속된다.
  4. if문의 조건값은 무조건 boolean(true, false)값이다.
  5. false 일땐 else 를 사용하면된다.
  6. if 와 else는 세트이다. else 단독 사용 불가가

### switch 문의 사용법을 설명할 수 있는가? []
  1. 문법 switch (조건){case"1": (문);break; default} 
  2. 단순한 값으로 프로그램을 제어할 수 있다면 사용한다.
  3. break로 문장을 멈춘다.
  4. 다른값을 입력하면 나오는 default 사용

### switch () 문에 사용할 수 있는 데이터 타입을 알고 있는가? []
  - int(byte,shor,int,char),문자열, 특별한 상수 enum이 올 수 있다.

### case 작성법을 알고 있는가? []
  - 리터럴 값만 올 수 있다.
  - 변수 사용 불가

### 상수를 표현할 때 final 대신 enum 방식의 이점을 설명할 수 있는가? []
  - 값을 직접 지정할 필요가 없다.
  - enum변수에는 지정한 값만 올 수 있다.
  - switch,case에 enum 타입의 값이 올 수 있다.

### while, do ~ while 반복문의 사용법을 설명할 수 있는가? [] lang.ex06.310
  - while (조건) -조건이 참일동안 계속 반복한다.
  -  continue 다음문장을 실행하지 않고 즉식 결과를 내놓는다

### for 반복문의 사용법을 설명할 수 있는가?
  - for(변수선언 초기화 ; 조건; 증감문)
  - 변수를 밖에다 선언하면 for문이 종료되어도 변수를 사용할 수 있다.
  - 배열과도 함께 사용이 가능한다.
  - 배열의 처음부터 끝까지 값을 꺼내는 것이라면 for문 사용
  - for (꺼낼값 저장할 변수 : 배열주소) 문장;

  ### for문으로 배열 꺼내기
  -  for (꺼낼값 저장할 변수 : 배열주소) 문장;

### 메서드를 실행할 때 값을 전달하는 방법을 알고 있는가? []
  - 메서드를 호출 할 때 파라미터는 아규먼트에서 값을 받아 실행한다.

### 프로그램의 표준입력스트림, 표준출력스트림, 오류스트림을 설명할 수 있는가? []
  - 표준입력스트림 -프로그램 외부에서 데이터가 들어 올 수 있는 기본 입구
    - System.in - 키보드로 받는 값
  - 표준 출력스트림 - 프르그램 실행 결과물을 외부로 보낼 수 있는 출구
    - System.out - 모니터,콘솔에 출력

### Scanner 클래스를 사용하는 이유를 설명할 수 있는가? []
  -  InputStream - 바이트 단위로 읽는 기능

### Scanner 클래스를 사용하여 키보드 입력을 처리할 수 있는가? []
  - java.util.Scannner keyboardScanner = new java.util.Scanner(keyboard)
  - java.util.Scanner keyScan = new java.util.Scanner(System.in)

### 메서드를 정의하고 사용하는 방법을 설명할 수 있는가? []
  - 코드를 관리하기 쉽고 재사용하기 쉽도록 기능 단위로 묶어 놓은 문법

### 메서드 시그너처(signature)와 바디(body)를 설명할 수 있는가? []
  - 메서드 시그너처 int plus(int a, int b) 리턴타입 시그니처(파라미터)
  - 바디는 밑에 문장이다.

### 메서드의 아규먼트와 파라미터를 설명할 수 있는가? []
  - 파라미터는 아규먼트로부터 받는 로컬 변수이다.
  - 아규먼트는 메서드에 넘겨주는 값이다.

### 가변 파라미터와 배열 파라미터의 특징을 비교 설명할 수 있는가? []
  - 가변파라미터
    - 값을 낱개로 넘길 수 있다.
    - 한개만 선언가능
    - 위치는 맨 뒤이다.
  - 배열 파라미터
    - 주소로 값을 넘길 수 있다.
    - 위치는 어디든 모두 가능하다.
    
### call by value와 call by reference를 비교 설명할 수 있는가? []
  - value는 stack(스택) 메모리이고 메서드를 호출 할 때 값을 넘긴다. 로컬변수이다.
  - refrence는 Heap메모리이고 주소 값을 넘긴다. 레퍼런스를 찾아가 배열 인스턴스의 값을 쓴다.

### JVM이 관리하는 메모리 영역을 용도에 따라 설명할 수 있는가? []
  - method Area 받은 데이터 값을 byte로 변환하여 저장한다.
  - stack 메서드의 로컬변수가 생성되는 곳이다. static변수
  - Heap은 new 명령어로 생성되는 곳이다. instence변수

### 재귀호출을 다룰 수 있는가? [] 
  - stack 메서드가 사용할 변수가 생성된다.

### 스택오버플로우 오류를 설명할 수 있는가? []
  - JVM Stack 계속해서 메모리가 쌓여 더 이상 로컬변수를 생성 할 수 없을 때를 말한다.

### GRASP의 'High Cohesion' 패턴에 대해 설명할 수 있는가? []
  - 각 개체가 밀접하게 연관되어있다.
  - 한 객체당 한개의 시스템
  - 재사용 하기 어렵다.

### GRASP의 'Low Coupling' 패턴에 대해 설명할 수 있는가? []
  - 각 개체,서브시템의 재사용성을 높이고, 시트메 관레 편하다.
  - 각 객체의 의존도 낮기때문에 재사용성이 높다.

### GRASP의 'Information Expert' 패턴에 대해 설명할 수 있는가? []
  - 책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여하는 것.
  - 역할을 수행할 객체에 역할을 부여하자.

### 클래스 문법의 용도에 대해 설명할 수 있는가? []
  - 다양한 데이터 타입들을 묶어 새롭게 정의한 데이터 타입

### 스태틱 변수에 대해 설명할 수 있는가? []
  - 스태틱 변수 = 클래스 변수 
  - 특정한 값,인스턴스, 특정한 변수가 아니면 static을 붙인다
  - 클래스 변수 사용을 위해 변수선언에 "static"을 붙인다.
  - 클래스가 메모리에 로딩될 때 자동으로 "Method Area에 생성된다
  - JVM이 종료되기 전까지 계속하여 존재한다.
  - static 000

### 인스턴스 변수에 대해 설명할 수 있는가? []
  - 작업결과를 개별적 관리하고 싶을때 인스턴스 변수 선언
  - 클래스가 로됭 될때 만들어지지 않는다.
  - "new" 명령어를 통해 만들 수 있다.
  -  인스턴스 주소를 통해서 접근 가능하다
  - this라는 내장변수가 자동 저장된다.(전달된 인스턴스 주소는 this에 자동 저장된다.)

### 인스턴스 메서드에 대해 설명할 수 있는가? []
  - 결과를 개별적으로 관리하고 싶을 때 사용한다.
  - 파라미터를 사용하여 그 결과를 내부적으로 저장한다.
  - 인스턴스의 레퍼런스가 있어야만 사용 가능하다.

### 패키지의 용도와 사용법을 설명할 수 있는가? []
  - 유지보수를 쉽게 하기위해
  - 역할에 따라 분류

### 클래스의 주요 용법 2가지를 설명할 수 있는가? []
  - 클래스 메서드 (static method)
  - 인스턴스 메서드 (non-static method)

### 클래스의 용도
  - 1. 메서드 분류
    - 서로 관련된 메서드를 묶어둔다.
    - 유지보수가 쉬워진다.
  - 2. 데이터 타입정의
    - 변수 - field
    - 연산자 - method

### 스태틱 변수(클래스 변수)의 생명주기를 알고 있는가? []
  - 클래스 메모리가 로딩될때 method area 생성된다.
  - JAVA JVM이 종료될때 사라진다.

### 스태틱 변수의 한계와 극복 방법을 아는가? []
  - 객체 지향적이지 못한다.
  - 다양하게 사용이 불가능하다.
  - 극복 방법은 인스턴스 메서드를 사용한다.

### 인스턴스 변수의 생명주기를 알고 있는가? []
  - new 명령어를 통해 Heap 메모리에 생성된다.
  - 실행이 끝나도 메모리는 사라지지 않는다
  - 메모리가 쌓이면 가비지 컬렉터에 의해 삭제된다.

### 인스턴스 메서드를 설명할 수 있는가? []
  - 작업을 개별적으로 관리 하고싶을 때 사용한다.
  - 오직 인스턴스 주소(레퍼런스)를 통해서만 접근이 가능하다.

### this 변수에 대해 설명할 수 있는가? []
  - 내장변수이고 생략이 가능하다.
  - this에 레퍼런스 주소가 자동 저장된다.
  - 파라미터로 인스턴스 주소를 전달할 필요가 없다.

### 메서드를 스태틱 메서드로 만들지 인스턴스 메서드로 만들지 구분할 수 있는가? []
  - 인스턴스, 특정한 값, 특정한 변수를 사용하지 않으면
  - static을 붙여라
  - 특정주소를 받는지 확인 (받으면 인스턴스)
  - 특정 메서드를 사용하는지 

### 생성자를 설명할 수 있는가? []
  - 인스턴스를 생성한 후 자동으로 생성된다.
  - this가 내장되어있다.
  - 자동으로 생성되고 자동으로 생략된다.
  - 파리미터값을 넘기느냐에 따라 생략이 정해진다.
  - 클래스 이름과 동일해야한다.
  - 객체 초기화를 위해 사용한다.

### 클래스 변수와 로컬 변수의 생명주기를 설명할 수 있는가? []
  - 클래스 변수는 클래스 로딩때 Method Area에서 생성되고 JVM이 종료 될때 사라진다
  - 로컬변수는 메서드 호출 때 JVM stack 에 생성되고 메서드 호출이 끝나면 사라진다.

### 클래스 로딩의 의미와 로딩 시점을 설명할 수 있는가? []  
  - 클래스를 사용하기 위해 클래스를 로딩하고 Method Area에 Staitc 변수가 생성된다

### 클래스 변수(스태틱 필드)를 사용할 때 한계점을 설명할 수 있는가? []
  - 개별적으로 사용하지 못하고
  - 다양하게 사용이 불가능 하다.

### 인스턴스 필드의 용도를 설명할 수 있는가? []
  - 작업을 개별적으로 관리 하고싶을때 사용한다.
  - new 명령어를 통해 Heap 메모리에 생성된다.

### 스태틱 메서드와 인스턴스 메서드의 용도를 설명할 수 있는가? []
  - 인스턴스 메서드는 인스턴스를 다루른 메서드이기 때문에 
  - 인스턴스를 다루지 않는다면 static 메서드이다.
  - this는 인스턴스 메서드만 사용하기 때문에 
  - 사용하지 않으면 static 메서드이다.

### 클래스가 로딩되는 시점을 설명할 수 있는가? []
   - 클래스를 사용하기 위해 메모리(method area)에 올릴 때를 클래스 로딩이라한다.
   - 올리는 메모리가 바로 static 변수 이다.

### 스태틱 필드와 인스턴스 필드의 생명주기를 설명할 수 있는가? []
  - static 필드는 클래스 메모리가 로딩될때 생성되고 JVM이 종료될때 사라진다.
  - 인스턴스 필드는 New명령어를 사용할때 Heap메모리에 생성되고 가비지 컬렉터에 의해 삭제된다.

### 스태틱 블록과 인스턴스 블록을 설명할 수 있는가? []
  - 스태틱 블록은 클래스 로딩될 때 한번만 실행된다.
  - 인스턴스 블록은 인스턴스가 생성될 때 마다 실행된다.
  - 생성자는 인스턴스 블록 실행 이후에 실행된다.

### static 블록
  1. 클래스로딩
  2. 스태틱 필드 생성
  3. static 블록 실행
  - 도중에 계산중 값이 없을 경우 로딩을 잠시 멈춘 후 
  - 다음 계산을 진행한다 그 다음 값을 구하여 
  - 멈췄던 계산을 마무리 한다.

### 변수 초기화문장을 설명할 수 있는가? []
  - 변수를 초기화 하는 문장이다.
  - 인스턴스,static 필드는 자동 초기화 된다.
  - string = null로 초기화 된다.
  - 모든 비트가 0이 되는 것을 말한다.
  - 스태틱
    - 순서대로 하나로 합쳐진다.
  - 인스턴스
    - 생성자로 합쳐진다

### 생성자를 설명할 수 있는가? []
  - 인스턴스 초기화를 위해 많이 사용된다.
  - 개발자가 생성자를 만들면 자동으로 생성되지 않는다.
  - 만들지 않는다면 자동으로 생성되고 자동으로 생략된다.

### this() 문장의 용도를 설명할 수 있는가? []
  - 생성자에서 다른 생성자를 호출 할때 사용한다.
  - this 첫번째 문장으로 와야한다.
  - 일반 메서드는 호출이 불가 하다.

### 인터페이스 문법의 용도를 설명할 수 있는가? []
  - 객체 사용규칙을 정의하는 문법이다.
  - 객체를 실행할 때 호출할 메서드를 선언한다.
  - 구현해서는 안된다.
  - abstract 추상메서드
  - public abstract 생략가능
  - implements 구현하다.
  - 인터페이스 규칙은 무조건 public 이다.

### SOLID의 OCP(Open/Closed Priciple) 원칙에 대해 설명할 수 있는가? []
   - 기능 추가 변경 삭제

### GRASP의 Low Coupling 책임 할당 원칙에 대해 설명할 수 있는가? []
  - 객체 간의 의존도를 낮춘다.
  - 유지 보수하기 좋게 만든다.

### GoF의 Composite 패턴을 설명할 수 있는가? []
  - 계층적인 구조로 만든다
  - 파일 시스템을 생각면 쉽다.
  - node 자식원소가 있는 원소
    - ex) git 폴더
  - leaf 자식원소가 없는 원소
    - ex) class 파일

### 클래스 메서드
  - static이 붙는다.
  - 모든 인스턴스가 공유
  - 클래스에 소속되어 있다.

### 메서드(Method) = 함수(function)
  - 코드를 관리하기 쉽고 재사용하기 쉽도록 기능 단위로 묶어 놓는 문법

### Informatin Expert
  - 정보를 갖고 있는 클래스에서 그 정보를 다룬다.

### java.lang.Object 
  - 자바의 최상위 클래스이다.
  - 모든 자바의 클래스는 object의 sub클래스이다.

### 제네릭(Generic)
  - 특정 타입만 사용하도록 제한하는 문법
  - < > <--- 타입파리미터, 타입이름을 받는 변수
  - 반환값의 타입을 형변환 할 필요가 없다.
  - 변수에는 대문자 한글자를 많이 사용한다.
  - 많이 사용하는 변수 E , T

### 다향성 polymorphic variable 문법
  - 하나의 객체가 여러가지 타입을 가질 수 있는 것

### 인테페이스
  - 객체의 규칙을 정하는 문법
  - 클래스로 정의할 수 없다.

### void 
  - 리턴 값이 없는 메서드는 void를 붙여야한다.

### return
  - 메서드 실행을 강제 종료하고 호출한 곳으로 돌아간다라는 의미이다.
  - return 값이 있는 메서드들은 return문으로 작성해야한다.

### 상속
  - 문법 class (subclass) extends (super 클래스){}
  - 기존 코드에 소스파일 필요없다. ---> class 파일만 잇으면된다
  - 기존 코드를 손대지 않는다 ---> 버그 추가될 가능성이 낮다.
  - 기존 클래스를 그대로 재사용 한다.
  - 상속은 기존 클래스를 쓰는거지 그대로 복사해 오는 것이 아니다.
  - 인스턴스를 생성할때 super클래스의 인스턴스 변수부터 만든다.

### overriding 오버라이딩 = 재정의
  - super클래스의 메서드를 sub클래스의 역할에 맞춰서 재정의 하는 것
  - 계산식메서드에 대해서 오버라이딩을 많이 한다.
  - 예제 score에서 super클래스에는 3개의 계산식의 평균이 정의되어있다.
  - 하지만 계산식이 추가되고 3개의 계산식으로는 계산이 불가하여
  - sub클래스에서 계산식을 재정의한다. 
  - 컴파일 시 @Override 라고 정확히 overriding되었는지 체크해준다.
```
실행

메서드
  - this는 실체 객체 기준
  - super는 메서드가 소속된 클래스 기준
필드
  - this는 메서드가 소속된 클래스 기준
  - super는 메서드가 소속된 클래스기준

```


### singleton (디자인 패턴)
  - 외부에서 생성자를 호출하지 못하도록 private으로 막는다.
  - 객체(인스턴스)를 딱 한개만 생성하도록 제약을 걸어야 할 필요가 있을 때 사용
  - 메모리를 절약할 수 있다.


### Factory Method(디자인 패턴)
  - 객체 생성과정이 복잡하여 캡슐화 시켰다.
  - 객체생성 코드를 단순하게 만들 수 있다.
  - 생성된 객체를 재활용할 수 있다.

### 옵저버 패턴 (디자인 패턴)
  - 일대다 관계
  -  상태를 저장하고 있는 객체가 변경되면 
  - 의존객체에게 연락이가고 자동으로 내용이 갱신되는 방식이다.

### getInstance
  - 객체 생성과정이 복잡하여 캡슐화 시켰다.

### IntegerPaseInt
  - 받은 값을 int로 형변환한다.

### 다형적 변수
  - 서브클래스의 인스턴스 주소도 저장할 수 있다.
  - 자식계체의 주소를 담은 래퍼런스는 
  - 레퍼런스가 실제 자식 객체를 가리킨다면,
  - 메서드를 찾을 때 자식 클래스의 오버라이딩 메서드를 먼저 찾는다.

### 필드
  - 클래스 블록에서 선언되며, 객체 내부에서 존재하고 객체 내 외부에서 사용가능

### 오버로딩
  - 추가 적재
  - 같은 이름의 메서드를 추가로 적재
  - 파라미터 정보가 같으면 안된다.
	- 파라미터 갯수, 타입이 달라야 한다.
  - 같은 기능을 수행하는 메서드에 관하여 같은 이름을 부여함으로써 프로그램의 일관성

### 추상 클래스
1. 목적
  - 앞에 abstract를 붙인다.
  - 서브클래스에게 공통필드나 메서드를 상속해주는 것이 목적
  - 여러 클래스를 같은 타입으로 묶기 위함
2. 용도
  - 서브 클래스들이 가져야할 공통 변수나 메서드를 제공하는 것이다.
  - 그래서 다음과 같이 일반 변수나 메서드를 정의할 수 있다.

  - 추상클래스는 인스턴스를 생성할 수 없다.

### 추상 메서드
  - 메서드 선언부에 abstract를 붙인다.
  - 추상 클래스나 인스터스에서만 선언할 수 있다.
  - 메서드 몸체가 없다
1. 용도
  - 서브 클래스가 반드시 구연해야할 메서드가 있을때 추상메서드 선언