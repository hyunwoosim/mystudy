# 쳌

### 배열을 만들고 사용할 수 있는가? []
  - 배열은 같은 종류의 메모리를 쉽게 만드는 방법이다.
  - 1. 메모리명[] 메모리이름 = new 메모리이름[]
  - 2. 데이터 타입[] 변수명 = new 데이터 타입[]
  - 메모리이름, 변수명 = 레퍼런스
  - new 000[] = 인스턴스 

### 레퍼런스와 인스턴스의 의미를 설명할 수 있는가? []
  - 레퍼런스 메모리의 주소값을 저장한다.
  - 인스턴스 메모리의 값을 저장한다.
### 조건연산자의 사용법을 설명할 수 있는가? []
  - 문법: 조건? 표현식1 : 표현식2

### statement(문장)와 expression(표현식)을 설명할 수 있는가? []
  - statement는 작업을 수행하는 명령
  - expression는 작업을 수행한 후 명령을 리턴하는 문장

### 전위 연산자와 후위 연산자의 사용법을 설명할 수 있는가? []
  - 전위연산자 (++,--)i 기존 변수값을 받고 연산한다.
  - 후위연산자 i(++,--)

### if문의 사용법을 설명할 수 있는가? [] lang.ex06
  1. 문법: if(조건) 문장, if(조건) {문장1,문장2}
  2. if문에서 여러개의 문장을 사용하고 싶다면 {}안에 문장을 넣는다.
  3. if문에는 문장 하나만 종속된다.
  4. if문의 조건값은 무조건 boolean(true, false)값이다.
  5. false 일땐 else 를 사용하면된다.
  6. if 와 else는 세트이다. else 단독 사용 불가가

### switch 문의 사용법을 설명할 수 있는가? []
  1. 문법 switch (조건){case"1": (문);break; default} 
  2. 단순한 값으로 프로그램을 제어할 수 있다면 사용한다.
  3. break로 문장을 멈춘다.
  4. 다른값을 입력하면 나오는 default 사용

### switch () 문에 사용할 수 있는 데이터 타입을 알고 있는가? []
  - int(byte,short,int,char),문자열, 특별한 상수 enum이 올 수 있다.

### case 작성법을 알고 있는가? []
  - 리터럴 값만 올 수 있다.
  - 변수 사용 불가

### 상수를 표현할 때 final 대신 enum 방식의 이점을 설명할 수 있는가? []
  - 값을 직접 지정할 필요가 없다.
  - enum변수에는 지정한 값만 올 수 있다.
  - switch,case에 enum 타입의 값이 올 수 있다.

### while, do ~ while 반복문의 사용법을 설명할 수 있는가? [] lang.ex06.310
  - while (조건) -조건이 참일동안 계속 반복한다.
  -  continue 다음문장을 실행하지 않고 즉식 결과를 내놓는다

### for 반복문의 사용법을 설명할 수 있는가?
  - for(변수선언 초기화 ; 조건; 증감문)
  - 변수를 밖에다 선언하면 for문이 종료되어도 변수를 사용할 수 있다.
  - 배열과도 함께 사용이 가능한다.
  - 배열의 처음부터 끝까지 값을 꺼내는 것이라면 for문 사용

  ### for문으로 배열 꺼내기
  -  for (꺼낼값 저장할 변수 : 배열주소) 문장;

### 메서드를 실행할 때 값을 전달하는 방법을 알고 있는가? []
  - 메서드를 호출 할 때 파라미터는 아규먼트에서 값을 받아 실행한다.

### 프로그램의 표준입력스트림, 표준출력스트림, 오류스트림을 설명할 수 있는가? []
  - 표준입력스트림 -프로그램 외부에서 데이터가 들어 올 수 있는 기본 입구
    - System.in - 키보드로 받는 값
  - 표준 출력스트림 - 프르그램 실행 결과물을 외부로 보낼 수 있는 출구
    - System.out - 모니터,콘솔에 출력

### Scanner 클래스를 사용하는 이유를 설명할 수 있는가? []
  -  InputStream - 바이트 단위로 읽는 기능

### Scanner 클래스를 사용하여 키보드 입력을 처리할 수 있는가? []
  - java.util.Scannner keyboardScanner = new java.util.Scanner(keyboard)
  - java.util.Scanner keyScan = new java.util.Scanner(System.in)

### 메서드를 정의하고 사용하는 방법을 설명할 수 있는가? []
  - 코드를 관리하기 쉽고 재사용하기 쉽도록 기능 단위로 묶어 놓은 문법

### 메서드 시그너처(signature)와 바디(body)를 설명할 수 있는가? []
  - 메서드 시그너처 int plus(int a, int b) 리턴타입 시그니처(파라미터)
  - 바디는 밑에 문장이다.

### 메서드의 아규먼트와 파라미터를 설명할 수 있는가? []
  - 파라미터는 아규먼트로부터 받는 로컬 변수이다.
  - 아규먼트는 메서드에 넘겨주는 값이다.

### 가변 파라미터와 배열 파라미터의 특징을 비교 설명할 수 있는가? []
  - 가변파라미터
    - 값을 낱개로 넘길 수 있다.
    - 한개만 선언가능
    - 위치는 맨 뒤이다.
  - 배열 파라미터
    - 주소로 값을 넘길 수 있다.
    - 위치는 어디든 모두 가능하다.
    
### call by value와 call by reference를 비교 설명할 수 있는가? []
  - value는 stack(스택) 메모리이고 메서드를 호출 할 때 값을 넘긴다. 로컬변수이다.
  - refrence는 Heap메모리이고 주소 값을 넘긴다. 레퍼런스를 찾아가 배열 인스턴스의 값을 쓴다.

### JVM이 관리하는 메모리 영역을 용도에 따라 설명할 수 있는가? []
  - method Area 받은 데이터 값을 byte로 변환하여 저장한다.
  - stack 메서드의 로컬변수가 생성되는 곳이다. static변수
  - Heap은 new 명령어로 생성되는 곳이다. instence변수

### 재귀호출을 다룰 수 있는가? [] 
  - stack 메서드가 사용할 변수가 생성된다.

### 스택오버플로우 오류를 설명할 수 있는가? []
  - JVM Stack 계속해서 메모리가 쌓여 더 이상 로컬변수를 생성 할 수 없을 때를 말한다.

### GRASP의 'High Cohesion' 패턴에 대해 설명할 수 있는가? []
  - 각 개체가 밀접하게 연관되어있다.
  - 한 객체당 한개의 시스템
  - 재사용 하기 어렵다.

### GRASP의 'Low Coupling' 패턴에 대해 설명할 수 있는가? []
  - 각 개체,서브시템의 재사용성을 높이고, 코드의 관리가 편하다.
  - 각 객체의 의존도 낮기때문에 재사용성이 높다.

### GRASP의 'Information Expert' 패턴에 대해 설명할 수 있는가? []
  - 책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여하는 것.
  - 역할을 수행할 객체에 역할을 부여하자.

### 클래스 문법의 용도에 대해 설명할 수 있는가? []
  - 다양한 데이터 타입들을 묶어 새롭게 정의한 데이터 타입

### 스태틱 변수에 대해 설명할 수 있는가? []
  - 스태틱 변수 = 클래스 변수 
  - 특정한 값,인스턴스, 특정한 변수가 아니면 static을 붙인다
  - 클래스 변수 사용을 위해 변수선언에 "static"을 붙인다.
  - 클래스가 메모리에 로딩될 때 자동으로 "Method Area에 생성된다
  - JVM이 종료되기 전까지 계속하여 존재한다.
  - static 000

### 인스턴스 변수에 대해 설명할 수 있는가? []
  - 작업결과를 개별적 관리하고 싶을때 인스턴스 변수 선언
  - 클래스가 로됭 될때 만들어지지 않는다.
  - "new" 명령어를 통해 만들 수 있다.
  -  인스턴스 주소를 통해서 접근 가능하다
  - this라는 내장변수가 자동 저장된다.(전달된 인스턴스 주소는 this에 자동 저장된다.)

### 인스턴스 메서드에 대해 설명할 수 있는가? []
  - 결과를 개별적으로 관리하고 싶을 때 사용한다.
  - 파라미터를 사용하여 그 결과를 내부적으로 저장한다.
  - 인스턴스의 레퍼런스가 있어야만 사용 가능하다.

### 패키지의 용도와 사용법을 설명할 수 있는가? []
  - 유지보수를 쉽게 하기위해
  - 역할에 따라 분류

### 클래스의 주요 용법 2가지를 설명할 수 있는가? []
  - 클래스 메서드 (static method)
  - 인스턴스 메서드 (non-static method)

### 클래스의 용도
  - 1. 메서드 분류
    - 서로 관련된 메서드를 묶어둔다.
    - 유지보수가 쉬워진다.
  - 2. 데이터 타입정의
    - 변수 - field
    - 연산자 - method

### 스태틱 변수(클래스 변수)의 생명주기를 알고 있는가? []
  - 클래스 메모리가 로딩될때 method area 생성된다.
  - JAVA JVM이 종료될때 사라진다.

### 스태틱 변수의 한계와 극복 방법을 아는가? []
  - 객체 지향적이지 못한다.
  - 다양하게 사용이 불가능하다.
  - 극복 방법은 인스턴스 메서드를 사용한다.

### 인스턴스 변수의 생명주기를 알고 있는가? []
  - new 명령어를 통해 Heap 메모리에 생성된다.
  - 실행이 끝나도 메모리는 사라지지 않는다
  - 메모리가 쌓이면 가비지 컬렉터에 의해 삭제된다.

### 인스턴스 메서드를 설명할 수 있는가? []
  - 작업을 개별적으로 관리 하고싶을 때 사용한다.
  - 오직 인스턴스 주소(레퍼런스)를 통해서만 접근이 가능하다.

### this 변수에 대해 설명할 수 있는가? []
  - 내장변수이고 생략이 가능하다.
  - this에 레퍼런스 주소가 자동 저장된다.
  - 파라미터로 인스턴스 주소를 전달할 필요가 없다.

### 메서드를 스태틱 메서드로 만들지 인스턴스 메서드로 만들지 구분할 수 있는가? []
  - 인스턴스, 특정한 값, 특정한 변수를 사용하지 않으면
  - static을 붙여라
  - 특정주소를 받는지 확인 (받으면 인스턴스)
  - 특정 메서드를 사용하는지 

### 생성자를 설명할 수 있는가? []
  - 인스턴스를 생성한 후 자동으로 생성된다.
  - this가 내장되어있다.
  - 자동으로 생성되고 자동으로 생략된다.
  - 파리미터값을 넘기느냐에 따라 생략이 정해진다.
  - 클래스 이름과 동일해야한다.
  - 객체 초기화를 위해 사용한다.

### 클래스 변수와 로컬 변수의 생명주기를 설명할 수 있는가? []
  - 클래스 변수는 클래스 로딩때 Method Area에서 생성되고 JVM이 종료 될때 사라진다
  - 로컬변수는 메서드 호출 때 JVM stack 에 생성되고 메서드 호출이 끝나면 사라진다.

### 클래스 로딩의 의미와 로딩 시점을 설명할 수 있는가? []  
  - 클래스를 사용하기 위해 클래스를 로딩하고 Method Area에 Staitc 변수가 생성된다

### 클래스 변수(스태틱 필드)를 사용할 때 한계점을 설명할 수 있는가? []
  - 개별적으로 사용하지 못하고
  - 다양하게 사용이 불가능 하다.

### 인스턴스 필드의 용도를 설명할 수 있는가? []
  - 작업을 개별적으로 관리 하고싶을때 사용한다.
  - new 명령어를 통해 Heap 메모리에 생성된다.

### 스태틱 메서드와 인스턴스 메서드의 용도를 설명할 수 있는가? []
  - 인스턴스 메서드는 인스턴스를 다루른 메서드이기 때문에 
  - 인스턴스를 다루지 않는다면 static 메서드이다.
  - this는 인스턴스 메서드만 사용하기 때문에 
  - 사용하지 않으면 static 메서드이다.

### 클래스가 로딩되는 시점을 설명할 수 있는가? []
   - 클래스를 사용하기 위해 메모리(method area)에 올릴 때를 클래스 로딩이라한다.
   - 올리는 메모리가 바로 static 변수 이다.

### 스태틱 필드와 인스턴스 필드의 생명주기를 설명할 수 있는가? []
  - static 필드는 클래스 메모리가 로딩될때 생성되고 JVM이 종료될때 사라진다.
  - 인스턴스 필드는 New명령어를 사용할때 Heap메모리에 생성되고 가비지 컬렉터에 의해 삭제된다.

### 스태틱 블록과 인스턴스 블록을 설명할 수 있는가? []
  - 스태틱 블록은 클래스 로딩될 때 한번만 실행된다.
  - 인스턴스 블록은 인스턴스가 생성될 때 마다 실행된다.
  - 생성자는 인스턴스 블록 실행 이후에 실행된다.

### static 블록
  1. 클래스로딩
  2. 스태틱 필드 생성
  3. static 블록 실행
  - 도중에 계산중 값이 없을 경우 로딩을 잠시 멈춘 후 
  - 다음 계산을 진행한다 그 다음 값을 구하여 
  - 멈췄던 계산을 마무리 한다.

### 변수 초기화문장을 설명할 수 있는가? []
  - 변수를 초기화 하는 문장이다.
  - 인스턴스,static 필드는 자동 초기화 된다.
  - string = null로 초기화 된다.
  - 모든 비트가 0이 되는 것을 말한다.
  - 스태틱
    - 순서대로 하나로 합쳐진다.
  - 인스턴스
    - 생성자로 합쳐진다

### 생성자를 설명할 수 있는가? []
  - 인스턴스 초기화를 위해 많이 사용된다.
  - 개발자가 생성자를 만들면 자동으로 생성되지 않는다.
  - 만들지 않는다면 자동으로 생성되고 자동으로 생략된다.

### this() 문장의 용도를 설명할 수 있는가? []
  - 생성자에서 다른 생성자를 호출 할때 사용한다.
  - this 첫번째 문장으로 와야한다.
  - 일반 메서드는 호출이 불가 하다.

### 인터페이스 문법의 용도를 설명할 수 있는가? []
  - 객체 사용규칙을 정의하는 문법이다.
  - 객체를 실행할 때 호출할 메서드를 선언한다.
  - 구현해서는 안된다.
  - abstract 추상메서드
  - public abstract 생략가능
  - implements 구현하다.
  - 인터페이스 규칙은 무조건 public 이다.

### SOLID의 OCP(Open/Closed Priciple) 원칙에 대해 설명할 수 있는가? []
   - 기능 추가 변경 삭제

### GRASP의 Low Coupling 책임 할당 원칙에 대해 설명할 수 있는가? []
  - 객체 간의 의존도를 낮춘다.
  - 유지 보수하기 좋게 만든다.

### GoF의 Composite 패턴을 설명할 수 있는가? []
  - 계층적인 구조로 만든다
  - 파일 시스템을 생각면 쉽다.
  - node 자식원소가 있는 원소
    - ex) git 폴더
  - leaf 자식원소가 없는 원소
    - ex) class 파일

### 클래스 메서드
  - static이 붙는다.
  - 모든 인스턴스가 공유
  - 클래스에 소속되어 있다.

### 메서드(Method) = 함수(function)
  - 코드를 관리하기 쉽고 재사용하기 쉽도록 기능 단위로 묶어 놓는 문법

### Informatin Expert
  - 정보를 갖고 있는 클래스에서 그 정보를 다룬다.

### java.lang.Object 
  - 자바의 최상위 클래스이다.
  - 모든 자바의 클래스는 object의 sub클래스이다.

### 제네릭(Generic)
  - 특정 타입만 사용하도록 제한하는 문법
  - < > <--- 타입파리미터, 타입이름을 받는 변수
  - 반환값의 타입을 형변환 할 필요가 없다.
  - 변수에는 대문자 한글자를 많이 사용한다.
  - 많이 사용하는 변수 E , T

### 다향성 polymorphic variable 문법
  - 하나의 객체가 여러가지 타입을 가질 수 있는 것

### 인테페이스
  - 객체의 규칙을 정하는 문법
  - 클래스로 정의할 수 없다.

### void 
  - 리턴 값이 없는 메서드는 void를 붙여야한다.

### return
  - 메서드 실행을 강제 종료하고 호출한 곳으로 돌아간다라는 의미이다.
  - return 값이 있는 메서드들은 return문으로 작성해야한다.

### 상속
  - 문법 class (subclass) extends (super 클래스){}
  - 기존 코드에 소스파일 필요없다. ---> class 파일만 잇으면된다
  - 기존 코드를 손대지 않는다 ---> 버그 추가될 가능성이 낮다.
  - 기존 클래스를 그대로 재사용 한다.
  - 상속은 기존 클래스를 쓰는거지 그대로 복사해 오는 것이 아니다.
  - 인스턴스를 생성할때 super클래스의 인스턴스 변수부터 만든다.

### overriding 오버라이딩 = 재정의
  - super클래스의 메서드를 sub클래스의 역할에 맞춰서 재정의 하는 것
  - 계산식메서드에 대해서 오버라이딩을 많이 한다.
  - 예제 score에서 super클래스에는 3개의 계산식의 평균이 정의되어있다.
  - 하지만 계산식이 추가되고 3개의 계산식으로는 계산이 불가하여
  - sub클래스에서 계산식을 재정의한다. 
  - 컴파일 시 @Override 라고 정확히 overriding되었는지 체크해준다.
```
실행

메서드
  - this는 실체 객체 기준
  - super는 메서드가 소속된 클래스 기준
필드
  - this는 메서드가 소속된 클래스 기준
  - super는 메서드가 소속된 클래스기준

```


### singleton (디자인 패턴)
  - 외부에서 생성자를 호출하지 못하도록 private으로 막는다.
  - 객체(인스턴스)를 딱 한개만 생성하도록 제약을 걸어야 할 필요가 있을 때 사용
  - 메모리를 절약할 수 있다.


### Factory Method(디자인 패턴)
  - 객체 생성과정이 복잡하여 캡슐화 시켰다.
  - 객체생성 코드를 단순하게 만들 수 있다.
  - 생성된 객체를 재활용할 수 있다.

### 옵저버 패턴 (디자인 패턴)
  - 일대다 관계
  -  상태를 저장하고 있는 객체가 변경되면 
  - 의존객체에게 연락이가고 자동으로 내용이 갱신되는 방식이다.

### getInstance
  - 객체 생성과정이 복잡하여 캡슐화 시켰다.

### IntegerPaseInt
  - 받은 값을 int로 형변환한다.

### 다형적 변수
  - 서브클래스의 인스턴스 주소도 저장할 수 있다.
  - 자식개체의 주소를 담은 래퍼런스는 
  - 레퍼런스가 실제 자식 객체를 가리킨다면,
  - 메서드를 찾을 때 자식 클래스의 오버라이딩 메서드를 먼저 찾는다.

### 다형적 변수 형변환 
  - sub클래스가 super 클래스로 형변환 되면
  - super클래스의 선언된 필드와 메서드만 사용할 수 있다.
  - 하지만 overriding된 메서드가 있다면 overriding메서드가 호출 된다.
  - 인스턴스를 생성하려면 클래스를 먼저 로딩해야 하는데
  - 수퍼 클래스부터 로딩된다
  - 그렇게 때문에 수퍼 클래스 필드,메서드를 먼저 접근
  - 예외 overriding된 메서드

### 다형성
  - 사용방법은 동일하지만 실행 결과는 다르게 나온다.
  - (사용방법 = 동일한 메서드)

### 필드
  - 클래스 블록에서 선언되며, 객체 내부에서 존재하고 객체 내 외부에서 사용가능

### 오버로딩
  - 추가 적재
  - 같은 이름의 메서드를 추가로 적재
  - 파라미터 정보가 같으면 안된다.
	- 파라미터 갯수, 타입이 달라야 한다.
  - 같은 기능을 수행하는 메서드에 관하여 같은 이름을 부여함으로써 프로그램의 일관성

### 추상 클래스
1. 목적
  - 앞에 abstract를 붙인다.
  - 서브클래스에게 공통필드나 메서드를 상속해주는 것이 목적
  - 여러 클래스를 같은 타입으로 묶기 위함
2. 용도
  - 서브 클래스들이 가져야할 공통 변수나 메서드를 제공하는 것이다.
  - 그래서 다음과 같이 일반 변수나 메서드를 정의할 수 있다.

  - 추상클래스는 인스턴스를 생성할 수 없다.

### 추상 메서드
  - 메서드 선언부에 abstract를 붙인다.
  - 추상 클래스나 인스터스에서만 선언할 수 있다.
  - 메서드 몸체가 없다
  - 일반메서드(concrete)는 추상메서드 선언 불가.
  - sub클래스에서 메서드를 반드시 재정의
  - 재정의는 sub클래스에서 한다.
1. 용도
  - 서브 클래스가 반드시 구연해야할 메서드가 있을때 추상메서드 선언
  - 서브 클래스에서 재정의 하도록 강요하고 싶을때
  
### Template 메서드
  - 실행흐름(알고리즘) 수퍼클래스에 정의하고
  - 구체적인 동작 정의는 sub클래스에 맡긴다.

### Specialization(전문화)
  - 수퍼 클래스를 상속받아 서브 클래스를 만드는 것

### Generalization(일반화)
  - 서브클래스의 공통기능을 뽑아 수퍼클래스를 만드는 것

### 추상화란?
  데이터화 + 연산자

### 용어
  - 연산자 = 메세지 = 메서드
  - 객체 = 사람, 사물

### 인터페이스의 정의
  - 인터페이스에 선언되는 메서드는 호출 규칙을 정의한 것이다.
  - 인터페이스에 선언되는 모든 메서드는 public이다.
    - public은 생략 가능
  - 인터페이스의 선언되는 모든 메서드는 추상메서드로 선언된다.
  - 선언되는 모드는 메서드는 몸체를 구현하지 않는다.
  - 인터페이스의 모든 메서드를 구현해야한다.
    - 빠뜨리면 추상메서드가 된다.

### 인터페이스 사용 이유 
  - 메서드 사용법이 통일되었다.
  - 유지보수하기 쉬워졌다.
  - 인터페이스 선언은 implements 키워드를 사용해야한다.
  - implements 키워드를 사용하면 반드시 '오버라이딩'해야한다.

### 인스턴스의 레퍼런스
  - 해당 인터페이스에 따라 작성된 클래스의 인스턴스 주소이다.
  - 000 사용규칙에 따라 작성된 클래스의 인스턴스 주소를 저장하는 변수
  - 000 타입 객체

### defalut 문법
  - 구현한 메서드이기 때문에 기존엔 만든 클래스에는 영향을 끼지치 않는다.
  - 새로운 규칙을 추가한다.
  - 새 메서드를 정의할 때 사용하는 문법
  - 단점 : 구현을 강제할 수 없다.

### 인터페이스의 다중 상속
  - 클래스와 다르게 다중 상속이 가능하다.
  - 수퍼 인터페이스의 메서드가 중복되도 상관없다.
    - 왜? 구현되지 않은 메서드이기 때문이다.

### 인터페이스의 다중상속 불가
  - 메서드의 리턴타입만 다를 경우 다중 상속이 불가하다.
    - 왜? 구분할 수 없기 때문이다.
    - 리턴 타입만 다른 메서드를 여러개 오버로딩할 수 없다.

### 인터페이스 다중 구현
  - 클래스가 인터페이스를 구현할때 다중구현이 가능하다.

### 인터페이스 다중 구현 불가
  - 데이터 타입이 다른 메서드가 구현된 경우
    - 어느 메서드가 상속 받아야할지 정할 수 없기떄문에
    - 다중 구현 불가!!!!


### 인터페이스와 추상클래스의 콜라보
  - 추상클래스가 최소상태로 모두 구현한다.
  - 그중에서 필요한 메서드만 "오버라이딩" 한다.

### eequals()
  - 상속 받은 인스턴스가 같은지를 비교한다.
  - == 연사자(비교연산자)와 같다
  - 인스턴스의 내용물이 같은지를 비교하려면 equals()을 오버라이딩 해야한다.
    - 오버라이딩을 하면 인스턴스주소가 달라도 문자열이 같으면 true
    - 오버라이딩을 하지 않으면 인스턴스주소가 다를땐 false가 나온다.
  - 오버라이딩을 하냐 안하냐의 차이로 결과값이 바뀐다.

### 인터페이스란?
  - 인터페이스란 객체사용 규칙이다.

### 인터페이스의 다중상속이 가능한 경우를 설명 할 수 있는가
  - 인터페이스가 클래스입장에서 오버로딩이 가능하다면 다중상속이 가능하다.
  - 오버로딩이 불가능하다면 다중상속이 불가능하다.
  - 메서드의 리턴타입만 다를경우 다중상속이 불가능하다

### defalut 메서드
  - 기존 인터페이스에 영향을 끼치지 않고 새로운 기능을 추가하는 문법이다.

### 인터페이스의 private 메서드 용도를 설명할 수 있는가
  - defalut 메서드가 공통으로 사용하는 코드를 두는 곳
  - 다른 클래스에서 호출 할 수 없다.
  - 같은 클래스 안에서는 호출이 가능하다.

### 인터페이스와 결합하는 추상클래스를 사용할 떄 
  - 추상클래스가 최소상태로 모두 구현한다.
  - 그중 필요한 메서드만 "오버 라이딩" 한다.

### object
  - 모든 자바 클래스는 object의 서브 클래스이다.

### toString()
  - 간단하게 클래스의 정보를 전달해 주는 문법이다.
  - 패키지명.클래스명@16진수해시값
  - 넘겨주는 값이 String 값이 아니라면
  - 객체에 toString을 호출한 후 리턴값을 출력한다.

### equals()
  - 상속 받은 인스턴스가 같은지 비교하는 문법이다.
  - == 연산자와 같다.
  - 오버라이딩을 하냐 안하냐에 따라 결과 값이 달라진다.
  - 오바라이딩 O 인스턴스가 달라도 내용물이 같다면 true
  - 오버라이딩 X 인스턴스가 다르면 false가 나온다.

### Hashcode = 디지털 지문
  - 값을 int값으로 리턴한다.
  - 데이터를 특정 수학 알고리즘을 따라 연산을 수행하여 짧은 코드로 표현한 것이다.
  - 계산을 했을 때 같은 해쉬 값이 나올 수 있다.

### 해시값 = 인스턴스 식별자
  - 주소가 아니다
  - 인스턴스가 같은지를 검사할 때 사용한다.
  - HashCode()를 재정의 하지 않고 그대로 사용하면 
  - 무조건 인스턴스마다 새 해시값이 부여된다.

### 중복 가능성, 데이터 충돌
  - 서로 다른 데이터가 같은 해쉬값을 가질 가능성이 있다.
  - 데이터 크기보다 해쉬값메모리가 커야 중복,충돌이 일어나지않는다 
  - 하지만 계산 시간은 늘어난다.
  - object의 리턴타입 int(4byte)이다.
  - hashCode의 리턴 값은 4byte이다.

### hashSet = Hash + set 의 데이터 저장 방식
  - 집합은 같은 값인 경우 중복 저장하지 않는다.
  - hashcode()의 리턴값이 같고 equals()의 메서드가 true라면 중복 저장하지 않는다.
  - 같은 값의 경우?
    - equals()와 hashCode()를 호출하여 중복 여부를 검사한다.
    - 저장할 때 위치는 hashCode()의 리턴 값을 사용하여 계산한다.

### hash map
  - 값을 저장할 때 key객체의 해시코드르 이용하여 저장할 위치를 계산한다.
  - 따라서 해시코드가 같다면 같은 key로 간주한다.
  -  hashcode()의 리턴값이 같고 equals()의 메서드가 true라면 중복 저장하지 않는다.
  

### getClass()
  - 클래스 정보를 리턴한다.
  - 클래스 정보로 부터 다양한 값을 꺼낼 수 있다.
    - getName
    - getSimpleName

### clone()
  - 인스턴스 복제기능을 활성화 하려면 Cloneable인터페이스를 구현해야 한다.
  - Shallow copy(얕은 복제), deep copy

### Shallow copy
  - 객체가 포함하는 의존 객체는 복제하지 않는다.
  - 그렇기 때문에 의존객체에 다른 값을 넣어도 값이 달라지지 않는다.
  - 의존객체의 레퍼런스가 같기 때문에 값이 변하지 않음

### deep copy
  - 의존 객체까지 복제한다 그렇기 때문에 새로운 주소의 의존객체가 생긴다.
  - 의존객체의 레퍼런스가 달라졌기 때문에 새로운 값을 넣으면 결과 값이 달라진다.

### String
  - 자바의 기본타입이 아닌다.
  - 클래스이다.

### String 인스턴스를 만드는 방법 2가지
  - new명령어로 Heap메모리에 생선한다.
  - String 리터럴을 사용하여 COnstant pool메모리에 생성한다.

### String에서 인스턴스를 비교할 때
  - equals를 사용한다 대 ,소문자도 비교대상이다.
  - 구분하지 않고 사용하고 싶다면 equalsIgnoreCase();를 사용하면된다.

### Constant pool = 상수풀
  - 상수를 따로 보관하는 인스턴스
  - 상수풀에 같은 값을 갖는 인스턴스가 있다면
  - 그 인스턴스 주소를 리턴한다. 같은 레퍼런스를 사용한다.
  - 이유 메모리 절약을 위해 인스턴스를 cache에 보관

### intern()
  - Heap영역에 String 인스턴스를 생성한다.
  - 생성한 객체 들어있는 문자열과 동일한 문자열을 찾고
  - 없으면 상수풀에 String 객체를 생성하고 그 주소를 리턴한다.
  - 있으면 그 String 객체의 주소를 리턴한다.
- 쓰는이유?
  - 만약 많은 문자열을 사용한다면 그 문자열을 다 적을 필요없이
  - Heap영역에 있는 주소를 intern()사용해서 전달하기만하면 쉽게 생성된다.

### String의 hashCode()
  - 문자열이 같으면 같은 hashCode()를 리턴하도록 오버라이딩 하였다.
  - 이유?
    - 문자열이 같은경우 같은 객체로 다루기 위함
    - hashSet에서 저장할 때 메서드의 리턴 값으로 저장위치를 계산한다.
    - hashMap이나 hashtable에서는 Key를 다룰 때 이 메서드의 리턴 값을 사용한다.
    - 보통 hashCode()와 equals()를 함께 오버라이딩 한다.

### String-toLowerCase
  - toLowerCase는 새로운 String 인스턴스를 생성한다.

### immutable = 불변 객체
  - string객체는 불변 객체이다.
  - 한번 값을 담음녀 변경할 수 없다.
  - toLowerCase메서드로 새로운 인스턴스를 만들어도 값은 변하지 않는다.

### StringBuilder와 멀티스레드
  - 여러 스레드가 동시에 버퍼를 사용하는 것을 막지 않는다.
  - 다른 스레드가 한 작업을 덮어 쓸 수 있다.
  - StringBuffer에 비해 빠르다.
  - Thread-safe하지않다.

### StringBuffer와 멀티스레드
  - 한번에 한 스레드만이 버퍼를 다루도록 제한한다.
  - 여러가 스레드가 동시에 사용하더라도 안전하다.
  - Thread-safe보장

### Thread-safe
  1. 여러 스레드가 같은 변수의 값을 동시에 변경하려 할 때
      한번에 한스레드만이 작업하도록 제한한 것
  2. 여러 스레드가 동시에 진입해서 명령을 실행하더라도 문제가 발생하지 않는 코드
    - 변수의 값을 조회만 하는 코드

### 동기화 처리
  - 동시에 여러 스레드 진입 불가

### StringBuffer(hashtable)와 StringBuilder(hashMap)
```
StringBuffer
  - 동기화 처리를 했기 때문에 여러스레드가 동시에 진입해도 스레드 세이프를 한다.
   대신 속도가 느리기 때문에 여러스레드가 작업할 때 적합하다.

StringBuilder
  - 동기화 처리를 하지 않았기 때문에 스레드가 세이프하지 못한다. 
  대신 실행속도가 빠르기 때문에 싱글스레드가 사용하기 적합하다.


```