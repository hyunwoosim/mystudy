# 복습

## Gradle 자바프로젝트를 Eclipse IDE 생성, Import

1. Eclipse IDE 생성 과정
```
Gradle --구성--> Java-basic (Root Project)/
                    |
                    |-App(Main Project)/ --Improt--> Eclipse IDE
```
2. Eclipse IDE 생성되는 설정파일(사용하는)
  - .settings/  <-- 프로젝트에 대한 더 상세한 설정
  - .classpath/  <-- 소스폴더 , 목적폴더, 외부라이브러리 정보
  - .projcet/   <-- 프로젝트 설정

3. Eclipse IDE 생성과정 명령어
```
1. $cd(폴더명) -생성할 폴더로 들어간다
2. $mkdir (파일명) -메인 프로젝트 파일명 작성
3. $cd(폴더명) 생성파일로 이동
4. $gradle init - Eclipes가사 사용하는 설정파일 자동생성
5. build.gradle 들어가서 플러그인 수정
  - id 'eclipse' - 플러그인을 수정해야 eclipse 사용가능
  - ecipse{ ~~~} - 전용플러그인 문법
6.gradle eclipse - 수정한 것을 적용(수정할 때마다 해야한다.)
7.Eclipse에 들어가서
   - improt-->general/Exisiting Projects into Workspace -->
   finish
```
### Eclipse VS Intelli J
1. Eclipse
- 개별 빌드이기 때문에 오류가 있어도 실행가능
```
Eclipse --사용--> JDK --> 빌드
```
2. Intelli J
- 전체 소스빌드 --> 일부소스에 오류있으면 실행 불가
```
Intelli J --사용--> Gradle --> JDK --> 빌드
```

## Data 보관 방법

1. 데이터 보관 과정
```
ex) 1.성적 데이터를 입력받으면
    2. -Information은 순위, 표준편차, 분포
       -Data는 평균,합계를 뽑아낸다

Data --가공--> S/W ----> Infor mation -순위, 표준편차, 분포
               |   
               |   ----> Data  -평균, 합계
               |
              H/W --CPU 연산
                  --RAM Data 보관

- S/W 가공하면 H/W 사용
- CPU는 연산
- RAM은 Data 확보 보관
```

2. 컴퓨터에서 데이터 보관
 - RAm , HDD, CD-ROM, SSD
  1. RAM
    - RAM은 비트에 전기(전하)를 저장함
    - 숫자를 전기신호로 변환하여 저장
    - 저장은 숫자, 문자, 색상, 소리 등등
```
|  | 0 | 0 |  |   <---비트
off on   on  off
```
  2. HDD
    - 자석 방향으로 저장
```
 N | S | S | N 
 S | N | N | S 
off on   on off
```
3. 데이터와 2진수
- on/off 표기가 불편하여 더 간결한 0/1 2진수 활용

### 숫자 ---> 2진수 변환 규칙
1. Sign-Mangitude
  - 맨 왼쪽 비트를 부호 비트로 사용 
  - 나머지 비트는 절대 값
  - 8비트 = 1비트(부호) + 7비트(절대값)
  - 수의 범위(8비트기준) : -127~ +127
```
양수(+) --> 0
음수(-)) --> 1
Ex) 
0001 --> +1
1001 --> -1
```
- 장점
  - 이해하기 쉽다
- 단점
  - 두개의 0 존재 (+0, -0)
  - 사람과 다른 연산 방식이 동작한다.
    - CPU 설치 복잡해짐,빼기를 처리하는 회로를 별도로 설계해야함
```
ex) 4bit예시
    0001  (+1)
+   1001  (-1)
--------------
=   0000  (0) 이 나와야하지만
--------------
=   1010  (-2)가 나온다
```

2. 1의 보수(보충해주는 수)
  - 모든 비트를 반대 값으로 바꾼다.
  - 수의 범위(8비트기준) -127~ +127
```
0000 0001 = +1
0000 0000 = +0
1111 1111 = -0
1111 1110 = -1
```
- 단점 
  - 두 개의 (+0, -0) 존재
  - 두 수를 더한 후 초과한 1 값을 맨 뒤에 더해야 옳은 값이된다.
```
  ex) 4비트 기준
      0100 (+4)
+     1101 (-2)
----------------
    1 0001  맨앞 초과한  1을 뒤에 더해야함
+        1
----------------
      0010 (+2)
```

3. 2의 보수, 장점
  - 양수 음수 덧셈 가능
  - 음수를 만들때 미리 1을 더해둔다.
  - Java에서 음수를 저장하는 방법
  - 1의 보수의 문제점 해결위해 등장한 방법
  - 0대한 표현 한 가지이다 -128까지 표현
  - 수의 범위 : -128 ~ +127 (0하나이기 때문이다)

### 2의 보수 만드는 방법 
1. 모든비트를 반대 값으로 만든 다음 1을 더 한다
```
Ex)    0010 1001   (+41)

       1101 0110   반대 값으로 만들기
+              1
----------------
       1101 0111 (-41)
```
2. 오른쪽에서부터 1을 찾는다
```
Ex1)
    0010 1001(+41) => 1101 0111(-41)
            ^                 ^
Ex2)
    0010 1100(+44) => 1101 0100(-44)
          ^                 ^
```
3. 2^n-음수값 (-2^n(8비트경우 2^8=256)에서 음수값을 뺀다)
```
Ex) 8비트기준
음수 값 = -41
=> 256 - 41 = 215 = 1101 0111
음수 값 = -44
=> 256 - 44 = 212 = 1101 0100
```
### 결론 정수는 2의보수 규칙에 따라 2진수로 변환 후 RAM에 저장

### 비트 크기별 저장할 수 있는 값의 범위, 메모리 단위별 메모리 크기
```
비트   |     비트 크기    |   메모리 크기   | jav:정수를 저장하는 호칭 
       
8bit   | -128 ~ +127      |      1byte      |    byte
16bit  | -32768 ~ +32767  |      2byte      |    short
32bit  | 약 -21억 ~ +21억  |      4byte      |     int
64bit  | 약 -92경 ~ +92경  |     8byte      |     long
```
## 부동소수점
- 정의 
  - 소수점 위치가 움직인다해서 부동(부유,둥둥뜨다)소수점이라한다
- 표기법
  - 숫자 e 지수
  - 숫자 E 지수
```
정규화(소수점 없애기)
0.0314e2 = 0.0314 * 10^2 = 3.14
314E-2 = 314 * 10^-2 = 3.14
```
- 32bit
```
|a|b|b|b|b|b|b|b|b|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
0                                                               31
a - 부호 - 1
b - 지수부 - 8
c - 가수부 - 23
```
### 부동 소수점 ->32bit 변화 과정
1. 10진수 -> 2진수로 바꾸기

``` ex) 12.375 (10진수)
1. 소수점 앞 2진수로 변환
  12 --> 1100
2. 소수점 뒤 *2 정수부분만 차례대로 표기 (0 or 반복되면 멈춘다)
  0.375 * 2 = 0.75 --> 0
  0.75 * 2  = 1.5  --> 1
  0.5 * 2   = 1.0  --> 1

결과 1100.011
```
2. 정규화 (가수부,지수부)
```
1.가수부 변환
  -소수점을 왼쪽 정수 1만 남도록 이동  --> 정규화
  1100.011 --> 1.100011
  - 소수점 왼쪽은 무조건 1이기 때문에 버린다. 오른쪽 수가 가수부
--> 0.100011 나머지부분은 0으로 채운다
가수부는 100011 이다

2. 정수부변환
  - 정규화 과정에서 이동한만큼 승 수 + IEEE 공식{2^(비트수 -1)}
  - 지수부는 8비트이다 2^8 = 128
  - 나온값(10진수) -->2진수 변환
  2^3 --> 3 + (128-1)
        = 3 + 127
        = 130
        130(10진수) --> 1000 0010(2진수)
정수부는 1000 0010
```
3. 32bit 표현하기
```
[0] [10000010] [10001100000000000000000]
부호   정수부            지수부
=> 0100_0001_0100_0110_0000_0000_0000_0000
=> 0x41460000
```

### 결론
- 2진수 4bit  -->16진수 1자리
- 간결한 표기,변환용이하여 16진수를 많이 사용한다

### IEEE-754 부동 소수점을 저장하는 메모리 크기
1. 32bit = float (단정도)
  - 4byte
  - 표기 (f,F)
  - 유효 자릿수 7자리

2. 64bit = double (배정도)
  - 8byte
  - 표기 (d, D)
  - 유효 자릿수 8 ~ 15자리
  - 단정도보다 2배이상 정말한 값을 보장할 수 있다.
```
        부호    지수부     가수부
32bit    1        8         23
64bit    1       11         52
```
- 부동소수점을 얼마나 정밀하게 저장할 수 있느냐는 메모리크기에 달렸다.

## 문자 
- 문자를 저장하는 원리
```
문자 --(문자집합)--> 2진수 --> RAM,HDD

Ex)
AB12(엔터) --2진수변환-->      41 42 31 32 0D 0A 61 62 0D 0A
 ad (엔터)                     A  B  1  2  엔터  a  d  엔터 
                                 총 10byte로 변환 된다

문자 집합 = Character set = charset
  -문자를 2진수로 변환하는 규칙
  - ASCII, ISO-8859-1, EUC-KR, UTF-8

문자가 깨지는 이유
  - 다른 코드표의 값을 보냈기 때문에
  ex) UTP-8문서를 ISO-8859-1 코드로 변환하면 깨진다
```

1. ASCII (미국 표준)
  - 7bit (0~127)
  - 95자 (인쇄 가능 문자)- 영어 알파벳 대,소문자, 숫자,특수문자 등
  - 33자 (인쇄 불가능 문자)
    - ex) LF(Line Feed)-> 0x0A -> 000 1010
    - ex) CR(Carrage Return) -> 0x0D -> 000 1110

2. ISO-8859-1 = ISO-Latin-1
  - 8bit
  - ASCII + 유럽문자

3. EUC-KR 
  - 16bit
  - ISO-8859 + 한글문자
  - 2350자(한글) + 한자(한,중) + 한자(한국전용) + 등등
  - 코드에 등록되지 않은 한글은 표기가 이상하게 나옴
    - Ex) 똠 --> 또+ㅁ

4. 조합형 - 초성 + 중성 + 종성
  - 최대 32자
  - 모든 한글을 표현가능
  - 국제 표준은 아니다

5. MS949 
  - EUC-KR + 나머지 한글 (11172자 지원)
  - 16bit
  - EUC 규칙을 그대로 사용 거기서 안쓰는 숫자들에 나머지 한글을 넣었다
  - 국제 표준은 아니다

6. Unicode (2byte ~ 4byte)
  - 새로 정의 했기때문에 한글에 순서대로 새로운 코드값이 부여됨
  - 영어도 2byte 사용 -> 메모리 낭비 -> UTF-8등장
- Java는 문자를 다룰때 Unicode(Ucs2)를 사용한다
  - Unicode(UCS2=UTF-16)
7. UTP-8
  - 유니코드의 포맷을 변형 하였다
  - 기존의 ASCII 문자열과 동일하다

### 리터럴 (Literal)
- 자바 언어로 표현한 값.

1. 2진수 리터럴
  - 메모리 상태를 직설적으로 보여줄 때 사용
  - 0b or 0B 시작
    - Ex) 0B11000100  = 100
    - Ex) 0b11000100  = 100

2. 16진수 리터럴
  - 0X or 0x 시작
    - 0X64  = 100
    - 0x64  = 100

3. 정수 리터럴 - 메모리 크기에 따른 표기법
- 4byte 정수 = 32bit = integer = int
  - 그냥 숫자 표시
  - 메모리 크기를 초과하면 컴파일 오류 발생
```
Ex)
4byte 양의정수 최대값 2147483647
      음의정수 최소값 -2147483648

최대값, 최소값 알아보는 명령어
  - 최대값 Integer.Max_VALUE
  - 최소값 Integer.MIN_VALUE
```

- 8byte 정수 = 64bit = long
  - 4byte 메모리 초고하는 정수값 표현할때 사용
  - 숫자 뒤에 L or l 을 붙인다.
  - 보통 대문자 L을 사용 소문자는 숫자 1과 헷갈리기때문
```
Ex)
8byte 양의정수 최대값 2147483648L
      음의정수 최소값 -2147483649L

최대값, 최소값 알아보는 명령어
  -최대값 Long.MAX_VALUE
  -최소값 Long.MIN_VALUE
```

4. 문자의 리터럴 - (' ') (char) (int) 
  - 작은 따옴표는 문자의 코드값을 알려주는 도구

- char 유니코드임을 알려주기위한 명령어
  - (char)65 -> A
- (' ') - 문자 코드 넘기기
  - ('A') -> A
- int 작은따옴표가 알려준 유니코드 그대로 출력
  - (int)'A' -> 65

5. 문자열 리터럴 (" ")
- 문자열은 자바의 기본 탑이 아니라 객체다
  - 객체 - 여러 데이터들의 덩어리
```
Ex)
기본 
("ABC가나다")
문자열에 유니코드 가능
("/u0041BC/uac00나다") => ("ABC가나다")
```
