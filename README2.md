# 복습

## Gradle 자바프로젝트를 Eclipse IDE 생성, Import

1. Eclipse IDE 생성 과정
```
Gradle --구성--> Java-basic (Root Project)/
                    |
                    |-App(Main Project)/ --Improt--> Eclipse IDE
```
2. Eclipse IDE 생성되는 설정파일(사용하는)
  - .settings/  <-- 프로젝트에 대한 더 상세한 설정
  - .classpath/  <-- 소스폴더 , 목적폴더, 외부라이브러리 정보
  - .projcet/   <-- 프로젝트 설정

3. Eclipse IDE 생성과정 명령어
```
1. $cd(폴더명) -생성할 폴더로 들어간다
2. $mkdir (파일명) -메인 프로젝트 파일명 작성
3. $cd(폴더명) 생성파일로 이동
4. $gradle init - Eclipes가사 사용하는 설정파일 자동생성
5. build.gradle 들어가서 플러그인 수정
  - id 'eclipse' - 플러그인을 수정해야 eclipse 사용가능
  - ecipse{ ~~~} - 전용플러그인 문법
6.gradle eclipse - 수정한 것을 적용(수정할 때마다 해야한다.)
7.Eclipse에 들어가서
   - improt-->general/Exisiting Projects into Workspace -->
   finish
```
### Eclipse VS Intelli J
1. Eclipse
- 개별 빌드이기 때문에 오류가 있어도 실행가능
```
Eclipse --사용--> JDK --> 빌드
```
2. Intelli J
- 전체 소스빌드 --> 일부소스에 오류있으면 실행 불가
```
Intelli J --사용--> Gradle --> JDK --> 빌드
```

## Data 보관 방법

1. 데이터 보관 과정
```
ex) 1.성적 데이터를 입력받으면
    2. -Information은 순위, 표준편차, 분포
       -Data는 평균,합계를 뽑아낸다

Data --가공--> S/W ----> Infor mation -순위, 표준편차, 분포
               |   
               |   ----> Data  -평균, 합계
               |
              H/W --CPU 연산
                  --RAM Data 보관

- S/W 가공하면 H/W 사용
- CPU는 연산
- RAM은 Data 확보 보관
```

2. 컴퓨터에서 데이터 보관
 - RAm , HDD, CD-ROM, SSD
  1. RAM
    - RAM은 비트에 전기(전하)를 저장함
    - 숫자를 전기신호로 변환하여 저장
    - 저장은 숫자, 문자, 색상, 소리 등등
```
|  | 0 | 0 |  |   <---비트
off on   on  off
```
  2. HDD
    - 자석 방향으로 저장
```
 N | S | S | N 
 S | N | N | S 
off on   on off
```
3. 데이터와 2진수
- on/off 표기가 불편하여 더 간결한 0/1 2진수 활용

### 숫자 ---> 2진수 변환 규칙
1. Sign-Mangitude
  - 맨 왼쪽 비트를 부호 비트로 사용 
  - 나머지 비트는 절대 값
  - 8비트 = 1비트(부호) + 7비트(절대값)
  - 수의 범위(8비트기준) : -127~ +127
```
양수(+) --> 0
음수(-)) --> 1
Ex) 
0001 --> +1
1001 --> -1
```
- 장점
  - 이해하기 쉽다
- 단점
  - 두개의 0 존재 (+0, -0)
  - 사람과 다른 연산 방식이 동작한다.
    - CPU 설치 복잡해짐,빼기를 처리하는 회로를 별도로 설계해야함
```
ex) 4bit예시
    0001  (+1)
+   1001  (-1)
--------------
=   0000  (0) 이 나와야하지만
--------------
=   1010  (-2)가 나온다
```

2. 1의 보수(보충해주는 수)
  - 모든 비트를 반대 값으로 바꾼다.
  - 수의 범위(8비트기준) -127~ +127
```
0000 0001 = +1
0000 0000 = +0
1111 1111 = -0
1111 1110 = -1
```
- 단점 
  - 두 개의 (+0, -0) 존재
  - 두 수를 더한 후 초과한 1 값을 맨 뒤에 더해야 옳은 값이된다.
```
  ex) 4비트 기준
      0100 (+4)
+     1101 (-2)
----------------
    1 0001  맨앞 초과한  1을 뒤에 더해야함
+        1
----------------
      0010 (+2)
```

3. 2의 보수, 장점
  - 양수 음수 덧셈 가능
  - 음수를 만들때 미리 1을 더해둔다.
  - Java에서 음수를 저장하는 방법
  - 1의 보수의 문제점 해결위해 등장한 방법
  - 0대한 표현 한 가지이다 -128까지 표현
  - 수의 범위 : -128 ~ +127 (0하나이기 때문이다)

### 2의 보수 만드는 방법 
1. 모든비트를 반대 값으로 만든 다음 1을 더 한다
```
Ex)    0010 1001   (+41)

       1101 0110   반대 값으로 만들기
+              1
----------------
       1101 0111 (-41)
```
2. 오른쪽에서부터 1을 찾는다
```
Ex1)
    0010 1001(+41) => 1101 0111(-41)
            ^                 ^
Ex2)
    0010 1100(+44) => 1101 0100(-44)
          ^                 ^
```
3. 2^n-음수값 (-2^n(8비트경우 2^8=256)에서 음수값을 뺀다)
```
Ex) 8비트기준
음수 값 = -41
=> 256 - 41 = 215 = 1101 0111
음수 값 = -44
=> 256 - 44 = 212 = 1101 0100
```
### 결론 정수는 2의보수 규칙에 따라 2진수로 변환 후 RAM에 저장

### 비트 크기별 저장할 수 있는 값의 범위, 메모리 단위별 메모리 크기
```
비트   |     비트 크기    |   메모리 크기   | jav:정수를 저장하는 호칭 
       
8bit   | -128 ~ +127      |      1byte      |    byte
16bit  | -32768 ~ +32767  |      2byte      |    short
32bit  | 약 -21억 ~ +21억  |      4byte      |     int
64bit  | 약 -92경 ~ +92경  |     8byte      |     long
```
## 부동소수점
- 정의 
  - 소수점 위치가 움직인다해서 부동(부유,둥둥뜨다)소수점이라한다
- 표기법
  - 숫자 e 지수
  - 숫자 E 지수
```
정규화(소수점 없애기)
0.0314e2 = 0.0314 * 10^2 = 3.14
314E-2 = 314 * 10^-2 = 3.14
```
- 32bit
```
|a|b|b|b|b|b|b|b|b|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
0                                                               31
a - 부호 - 1
b - 지수부 - 8
c - 가수부 - 23
```
### 부동 소수점 ->32bit 변화 과정
1. 10진수 -> 2진수로 바꾸기

``` ex) 12.375 (10진수)
1. 소수점 앞 2진수로 변환
  12 --> 1100
2. 소수점 뒤 *2 정수부분만 차례대로 표기 (0 or 반복되면 멈춘다)
  0.375 * 2 = 0.75 --> 0
  0.75 * 2  = 1.5  --> 1
  0.5 * 2   = 1.0  --> 1

결과 1100.011
```
2. 정규화 (가수부,지수부)
```
1.가수부 변환
  -소수점을 왼쪽 정수 1만 남도록 이동  --> 정규화
  1100.011 --> 1.100011
  - 소수점 왼쪽은 무조건 1이기 때문에 버린다. 오른쪽 수가 가수부
--> 0.100011 나머지부분은 0으로 채운다
가수부는 100011 이다

2. 정수부변환
  - 정규화 과정에서 이동한만큼 승 수 + IEEE 공식{2^(비트수 -1)}
  - 지수부는 8비트이다 2^8 = 128
  - 나온값(10진수) -->2진수 변환
  2^3 --> 3 + (128-1)
        = 3 + 127
        = 130
        130(10진수) --> 1000 0010(2진수)
정수부는 1000 0010
```
3. 32bit 표현하기
```
[0] [10000010] [10001100000000000000000]
부호   정수부            지수부
=> 0100_0001_0100_0110_0000_0000_0000_0000
=> 0x41460000
```

### 결론
- 2진수 4bit  -->16진수 1자리
- 간결한 표기,변환용이하여 16진수를 많이 사용한다